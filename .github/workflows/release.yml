name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: ubuntu-24.04
    container: ubuntu:24.04
    permissions:
      contents: write
      pages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install build dependencies
      run: |
        apt-get update
        apt-get install -y \
          git \
          clang \
          make \
          flex \
          bison \
          libreadline-dev \
          libcap-dev \
          libelf-dev \
          zlib1g-dev \
          pkg-config \
          build-essential \
          linux-headers-generic \
          libbpf-dev \
          libsystemd-dev \
          linux-tools-common \
          linux-tools-generic \
          gnupg \
          apt-utils \
          dpkg-dev \
          debhelper \
          devscripts \
          dh-make

    - name: Install correct libbpf version
      run: |
        # For noble, ensure we have libbpf1 and remove any libbpf0
        echo "Ubuntu 24.04 (noble) detected, installing libbpf1 and libbpf-dev"
        apt-get install -y libbpf1 libbpf-dev
        
        # Remove libbpf0 if it exists to ensure we link against libbpf1
        apt-get remove -y libbpf0 || true
        apt-get autoremove -y
        
        # Verify pkg-config finds the correct libbpf
        echo "Checking pkg-config libbpf configuration:"
        pkg-config --libs --cflags libbpf

    - name: Ensure bpftool
      run: |
        set -e
        echo "Checking for bpftool..."
        if command -v bpftool >/dev/null 2>&1; then
          echo "bpftool already available: $(bpftool version)"
          exit 0
        fi

        echo "bpftool not found, installing..."
        
        # First, try to find any existing bpftool in linux-tools directories
        BPFDIR=$(ls -d /usr/lib/linux-tools-* 2>/dev/null | head -n1 || true)
        if [ -n "$BPFDIR" ] && [ -x "$BPFDIR/bpftool" ]; then
          echo "Found existing bpftool in $BPFDIR"
          ln -sf "$BPFDIR/bpftool" /usr/local/bin/bpftool
          bpftool version
          exit 0
        fi
        
        # Try to install any available linux-tools packages
        echo "Trying to install available linux-tools packages..."
        apt-get update >/dev/null 2>&1
        
        # Find available linux-tools packages and install them
        AVAILABLE_TOOLS=$(apt-cache search "^linux-tools-[0-9]" | grep -o "linux-tools-[0-9][^ ]*" | head -5)
        for pkg in $AVAILABLE_TOOLS; do
          echo "Trying to install $pkg..."
          if apt-get install -y "$pkg" >/dev/null 2>&1; then
            echo "Successfully installed $pkg"
            # Check if it provided bpftool
            BPFDIR=$(ls -d /usr/lib/linux-tools-* 2>/dev/null | head -n1 || true)
            if [ -n "$BPFDIR" ] && [ -x "$BPFDIR/bpftool" ]; then
              ln -sf "$BPFDIR/bpftool" /usr/local/bin/bpftool
              bpftool version
              exit 0
            fi
          fi
        done
        
        # If all else fails, build from source
        echo "No distro bpftool found, building from source..."
        rm -rf /tmp/bpftool-src
        git clone --depth 1 --recurse-submodules https://github.com/libbpf/bpftool.git /tmp/bpftool-src
        make -C /tmp/bpftool-src -j$(nproc)
        install -m 0755 /tmp/bpftool-src/src/bpftool /usr/local/bin/bpftool
        rm -rf /tmp/bpftool-src
        
        echo "Verifying bpftool installation..."
        bpftool version

    - name: Build application
      run: |
        make clean
        make

    - name: Update changelog with version
      run: |
        VERSION=${GITHUB_REF#refs/tags/}
        VERSION=${VERSION#v}
        # Update the first version found in changelog
        sed -i "1,/^tty-egpf-monitor/{s/^tty-egpf-monitor ([^)]*)/tty-egpf-monitor ($VERSION-1)/}" debian/changelog
        echo "Updated changelog to version $VERSION-1"
        head -n 10 debian/changelog

    - name: Clean Debian outputs
      run: |
        rm -f ../*.deb ../*.buildinfo ../*.changes || true
        rm -rf debian/tty-egpf-monitor debian/tty-egpf-monitord debian/tty-egpf-monitor-cli || true

    - name: Build Debian package
      run: |
        echo "Building package with flexible libbpf dependency (libbpf0 | libbpf1)"
        echo "Final debian/control:"
        cat debian/control
        
        dpkg-buildpackage -b -us -uc
        ls -la ../*.deb

    - name: Copy Debian packages to workspace
      run: |
        cp ../*.deb .

    - name: Publish apt repo to gh-pages
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        REPO: ${{ github.repository }}
      run: |
        set -e
        git config --global user.name "github-actions"
        git config --global user.email "github-actions@users.noreply.github.com"
        rm -rf /tmp/apt-repo
        git clone --depth 1 --branch gh-pages "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git" /tmp/apt-repo || {
          mkdir -p /tmp/apt-repo
          cd /tmp/apt-repo
          git init
          git checkout -b gh-pages
          git remote add origin "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git"
          cd -
        }

        # Create pool directory
        mkdir -p /tmp/apt-repo/pool/main
        cp *.deb /tmp/apt-repo/pool/main/ 2>/dev/null || true
        
        echo "Packages in pool:"
        ls -la /tmp/apt-repo/pool/main/ 2>/dev/null || echo "No packages"

        # Update packages for both codenames
        for CODENAME in noble jammy; do
          echo "Processing $CODENAME..."
          mkdir -p /tmp/apt-repo/dists/${CODENAME}/main/binary-amd64
          cd /tmp/apt-repo
          
          apt-ftparchive packages pool/main > dists/${CODENAME}/main/binary-amd64/Packages
          gzip -c dists/${CODENAME}/main/binary-amd64/Packages > dists/${CODENAME}/main/binary-amd64/Packages.gz
          apt-ftparchive \
            -o APT::FTPArchive::Release::Label="tty-egpf-monitor" \
            -o APT::FTPArchive::Release::Suite="${CODENAME}" \
            -o APT::FTPArchive::Release::Codename="${CODENAME}" \
            -o APT::FTPArchive::Release::Architectures="amd64" \
            -o APT::FTPArchive::Release::Components="main" \
            release dists/${CODENAME} > dists/${CODENAME}/Release
          cd -
        done

        cd /tmp/apt-repo
        touch .nojekyll
        # Copy index.html for better repository presentation
        cp "$GITHUB_WORKSPACE/index.html" ./index.html || true
        
        # Publish public key at root for clients
        KEYASC=""
        if [ -f "$GITHUB_WORKSPACE/public-apt-key.asc" ]; then
          cp "$GITHUB_WORKSPACE/public-apt-key.asc" ./public-apt-key.asc
          KEYASC="public-apt-key.asc"
        else
          CAND=$(ls "$GITHUB_WORKSPACE"/*.asc 2>/dev/null | head -n1 || true)
          if [ -n "$CAND" ]; then
            cp "$CAND" ./public-apt-key.asc
            KEYASC="public-apt-key.asc"
          elif [ -n "$GPG_PRIVATE_KEY" ]; then
            echo "$GPG_PRIVATE_KEY" | gpg --batch --yes --import
            gpg --armor --export > ./public-apt-key.asc || true
            KEYASC="public-apt-key.asc"
          fi
        fi
        if [ -n "$KEYASC" ]; then
          gpg --dearmor < "$KEYASC" > ./public-apt-key.gpg || true
        fi

        # Sign release files for both codenames
        if [ -n "$GPG_PRIVATE_KEY" ]; then
          echo "$GPG_PRIVATE_KEY" | gpg --batch --yes --import
          for CODENAME in noble jammy; do
            gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" -abs -o dists/${CODENAME}/Release.gpg dists/${CODENAME}/Release
            gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --clearsign -o dists/${CODENAME}/InRelease dists/${CODENAME}/Release || true
          done
        fi

        git add -A
        git commit -m "Update apt repo for ${GITHUB_REF}" || git commit -m "Initialize apt repo"
        git push -u origin gh-pages

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        files: '*.deb'
        generate_release_notes: true
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}