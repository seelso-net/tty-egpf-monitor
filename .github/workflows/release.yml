name: Release

# IMPORTANT: This workflow now builds packages compatible with both kernel 5.15.x and 6.8.x
# by using HWE kernel headers (linux-headers-generic-hwe-22.04) instead of generic headers.
# This ensures packages work on Ubuntu 22.04 machines running newer kernels.

on:
  push:
    branches:
      - main
    tags:
      - 'v*'

jobs:
  # Test build on main push
  test-build:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Test build
      run: |
        echo "Testing build on main branch"
        # Add build test commands here if needed

  # Build for Ubuntu 24.04 (noble) - existing job
  build-noble:
    runs-on: ubuntu-24.04
    container: ubuntu:24.04
    if: startsWith(github.ref, 'refs/tags/')
    permissions:
      contents: write
      pages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install build dependencies
      run: |
        apt-get update
        apt-get install -y \
          git \
          clang \
          make \
          flex \
          bison \
          libreadline-dev \
          libcap-dev \
          libelf-dev \
          zlib1g-dev \
          pkg-config \
          build-essential \
          linux-headers-generic \
          libbpf-dev \
          libsystemd-dev \
          linux-tools-common \
          linux-tools-generic \
          gnupg \
          apt-utils \
          dpkg-dev \
          debhelper \
          devscripts \
          dh-make

    - name: Install correct libbpf version
      run: |
        # For noble, build and install libbpf 1.6.2 to ensure compatibility
        echo "Ubuntu 24.04 (noble) detected, building libbpf 1.6.2"
        
        # Install build dependencies for libbpf
        apt-get install -y libelf-dev zlib1g-dev
        
        # Build and install libbpf 1.6.2
        cd /tmp
        git clone --depth 1 --branch v1.6.2 https://github.com/libbpf/libbpf.git
        cd libbpf/src
        make
        
        # Remove any existing libbpf installations to avoid conflicts
        echo "Removing existing libbpf installations..."
        rm -f /usr/local/lib/libbpf.so* /usr/local/lib64/libbpf.so* /usr/local/lib/libbpf.a /usr/local/lib64/libbpf.a 2>/dev/null || true
        rm -rf /usr/local/include/bpf 2>/dev/null || true
        rm -f /usr/local/lib/pkgconfig/libbpf.pc /usr/local/lib64/pkgconfig/libbpf.pc 2>/dev/null || true
        
        # Install with explicit paths to ensure proper installation
        make install PREFIX=/usr/local
        ldconfig
        
        # Verify what was actually installed
        echo "Checking installation results:"
        ls -la /usr/local/lib/ || echo "No /usr/local/lib directory"
        ls -la /usr/local/include/ | grep bpf || echo "No bpf headers found"
        find /usr/local -name "libbpf*" 2>/dev/null || echo "No libbpf files found in /usr/local"
        
        # Verify libbpf 1.6.2 is installed and working
        echo "Verifying libbpf 1.6.2 installation:"
        
        # Check both lib and lib64 directories (64-bit systems use lib64)
        LIBBPF_FOUND=false
        
        # Check /usr/local/lib64 first (64-bit systems)
        if [ -f /usr/local/lib64/libbpf.so.1 ]; then
          echo "libbpf.so.1 found in /usr/local/lib64"
          ls -la /usr/local/lib64/libbpf.so*
          LIBBPF_FOUND=true
        elif [ -f /usr/local/lib64/libbpf.so.1.6.2 ]; then
          echo "libbpf.so.1.6.2 found in /usr/local/lib64"
          ls -la /usr/local/lib64/libbpf.so*
          # Create symlink if needed
          if [ ! -f /usr/local/lib64/libbpf.so.1 ]; then
            ln -sf /usr/local/lib64/libbpf.so.1.6.2 /usr/local/lib64/libbpf.so.1
            echo "Created symlink libbpf.so.1 -> libbpf.so.1.6.2 in /usr/local/lib64"
          fi
          LIBBPF_FOUND=true
        fi
        
        # Check /usr/local/lib (32-bit systems or fallback)
        if [ "$LIBBPF_FOUND" = "false" ]; then
          if [ -f /usr/local/lib/libbpf.so.1 ]; then
            echo "libbpf.so.1 found in /usr/local/lib"
            ls -la /usr/local/lib/libbpf.so*
            LIBBPF_FOUND=true
          elif [ -f /usr/local/lib/libbpf.so.1.6.2 ]; then
            echo "libbpf.so.1.6.2 found in /usr/local/lib"
            ls -la /usr/local/lib/libbpf.so*
            # Create symlink if needed
            if [ ! -f /usr/local/lib/libbpf.so.1 ]; then
              ln -sf /usr/local/lib/libbpf.so.1.6.2 /usr/local/lib/libbpf.so.1
              echo "Created symlink libbpf.so.1 -> libbpf.so.1.6.2 in /usr/local/lib"
            fi
            LIBBPF_FOUND=true
          fi
        fi
        
        if [ "$LIBBPF_FOUND" = "false" ]; then
          echo "ERROR: libbpf.so.1 or libbpf.so.1.6.2 not found in /usr/local/lib or /usr/local/lib64"
          echo "Available files in /usr/local/lib:"
          ls -la /usr/local/lib/ || true
          echo "Available files in /usr/local/lib64:"
          ls -la /usr/local/lib64/ || true
          exit 1
        fi
        
        # Test libbpf version programmatically
        echo "Testing libbpf version compatibility..."
        cat > /tmp/test_libbpf.c << 'EOF'
        #include <stdio.h>
        #include <bpf/libbpf.h>
        int main() {
            unsigned int major = libbpf_major_version();
            unsigned int minor = libbpf_minor_version();
            const char *version_str = libbpf_version_string();
            
            printf("libbpf version: %u.%u (%s)\n", major, minor, version_str);
            
            // Verify we have libbpf 1.6.2
            if (major != 1 || minor < 6) {
                printf("ERROR: Expected libbpf 1.6.2, got %u.%u\n", major, minor);
                return 1;
            }
            
            printf("libbpf version check: PASSED (1.6.2)\n");
            return 0;
        }
        EOF
        
        gcc -o /tmp/test_libbpf /tmp/test_libbpf.c -L/usr/local/lib64 -lbpf -Wl,-rpath,/usr/local/lib64
        /tmp/test_libbpf
        rm -f /tmp/test_libbpf /tmp/test_libbpf.c

    - name: Ensure bpftool
      run: |
        set -e
        echo "Checking for bpftool..."
        if command -v bpftool >/dev/null 2>&1; then
          echo "bpftool already available: $(bpftool version)"
          exit 0
        fi

        echo "bpftool not found, installing..."
        
        # First, try to find any existing bpftool in linux-tools directories
        BPFDIR=$(ls -d /usr/lib/linux-tools-* 2>/dev/null | head -n1 || true)
        if [ -n "$BPFDIR" ] && [ -x "$BPFDIR/bpftool" ]; then
          echo "Found existing bpftool in $BPFDIR"
          ln -sf "$BPFDIR/bpftool" /usr/local/bin/bpftool
          bpftool version
          exit 0
        fi
        
        # Try to install any available linux-tools packages
        echo "Trying to install available linux-tools packages..."
        apt-get update >/dev/null 2>&1
        
        # Find available linux-tools packages and install them
        AVAILABLE_TOOLS=$(apt-cache search "^linux-tools-[0-9]" | grep -o "linux-tools-[0-9][^ ]*" | head -5)
        for pkg in $AVAILABLE_TOOLS; do
          echo "Trying to install $pkg..."
          if apt-get install -y "$pkg" >/dev/null 2>&1; then
            echo "Successfully installed $pkg"
            # Check if it provided bpftool
            BPFDIR=$(ls -d /usr/lib/linux-tools-* 2>/dev/null | head -n1 || true)
            if [ -n "$BPFDIR" ] && [ -x "$BPFDIR/bpftool" ]; then
              ln -sf "$BPFDIR/bpftool" /usr/local/bin/bpftool
              bpftool version
              exit 0
            fi
          fi
        done
        
        # If all else fails, build from source
        echo "No distro bpftool found, building from source..."
        rm -rf /tmp/bpftool-src
        git clone --depth 1 --recurse-submodules https://github.com/libbpf/bpftool.git /tmp/bpftool-src
        make -C /tmp/bpftool-src -j$(nproc)
        install -m 0755 /tmp/bpftool-src/src/bpftool /usr/local/bin/bpftool
        rm -rf /tmp/bpftool-src
        
        echo "Verifying bpftool installation..."
        bpftool version

    - name: Build application
      run: |
        make clean
        make

    - name: Check if this is a tag release
      id: check_tag
      run: |
        echo "DEBUG: GITHUB_REF = $GITHUB_REF"
        echo "DEBUG: GITHUB_EVENT_NAME = $GITHUB_EVENT_NAME"
        echo "DEBUG: GITHUB_REF_TYPE = $GITHUB_REF_TYPE"
        if [[ "$GITHUB_REF_TYPE" == "tag" ]]; then
          echo "is_tag=true" >> $GITHUB_OUTPUT
          echo "This is a tag release, will build packages"
        else
          echo "is_tag=false" >> $GITHUB_OUTPUT
          echo "This is a push to main, build test only"
        fi
        echo "DEBUG: is_tag value set to: $(cat $GITHUB_OUTPUT || echo 'empty')"

    - name: Update changelog with version
      run: |
        VERSION=${GITHUB_REF#refs/tags/}
        VERSION=${VERSION#v}
        sed -i "s/1.0.0-1/$VERSION-1/" debian/changelog
        # Replace first parenthesised version in changelog with new version
        sed -Ei "0,/tty-egpf-monitor \([^)]+\)/s//tty-egpf-monitor (${VERSION}-1)/" debian/changelog

    - name: Clean Debian outputs
      run: |
        rm -f ../*.deb ../*.buildinfo ../*.changes || true
        rm -rf debian/tty-egpf-monitor debian/tty-egpf-monitord debian/tty-egpf-monitor-cli || true

    - name: Build Debian package
      run: |
        echo "Building package for Ubuntu 24.04 (noble)"
        echo "Final debian/control:"
        cat debian/control
        
        dpkg-buildpackage -b -us -uc
        ls -la ../*.deb

    - name: Copy and rename Debian packages
      run: |
        mkdir -p noble-packages
        for f in ../*.deb; do
          base=$(basename "$f" .deb)
          cp "$f" "noble-packages/${base}~noble.deb"
        done

    - name: Upload noble packages
      uses: actions/upload-artifact@v4
      with:
        name: noble-packages-${{ github.ref_name }}
        path: noble-packages/*.deb
        
    - name: List all built packages (always)
      if: always()
      run: |
        echo "=== Listing all .deb files found ==="
        find . -name "*.deb" -type f 2>/dev/null || echo "No .deb files found"

    - name: Debug - Check if packages were built
      if: always()
      run: |
        echo "DEBUG: Checking if packages were built..."
        echo "DEBUG: Current directory: $(pwd)"
        echo "DEBUG: is_tag output = ${{ steps.check_tag.outputs.is_tag }}"
        echo "DEBUG: GITHUB_REF = ${{ github.ref }}"
        echo "DEBUG: GITHUB_REF_NAME = ${{ github.ref_name }}"
        echo "DEBUG: Noble packages directory:"
        ls -la noble-packages/ 2>/dev/null || echo "No noble-packages directory"
        echo "DEBUG: Parent directory .deb files:"
        ls -la ../*.deb 2>/dev/null || echo "No .deb files in parent directory"

  # Build for Ubuntu 22.04 (jammy) - new job
  build-jammy:
    runs-on: ubuntu-latest
    container: ubuntu:22.04
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install build dependencies
      run: |
        apt-get update
        apt-get install -y \
          git \
          clang \
          make \
          flex \
          bison \
          libreadline-dev \
          libcap-dev \
          libelf-dev \
          zlib1g-dev \
          pkg-config \
          build-essential \
          linux-headers-generic-hwe-22.04 \
          linux-tools-generic-hwe-22.04 \
          libbpf-dev \
          libsystemd-dev \
          gnupg \
          apt-utils \
          dpkg-dev \
          debhelper \
          devscripts \
          dh-make

    - name: Install compatible libbpf version
      run: |
        # For jammy, build and install libbpf 1.6.2 to ensure compatibility
        echo "Ubuntu 22.04 (jammy) detected, building libbpf 1.6.2"
        
        # Install build dependencies for libbpf
        apt-get install -y libelf-dev zlib1g-dev
        
        # Build and install libbpf 1.6.2
        cd /tmp
        git clone --depth 1 --branch v1.6.2 https://github.com/libbpf/libbpf.git
        cd libbpf/src
        make
        
        # Remove any existing libbpf installations to avoid conflicts
        echo "Removing existing libbpf installations..."
        rm -f /usr/local/lib/libbpf.so* /usr/local/lib64/libbpf.so* /usr/local/lib/libbpf.a /usr/local/lib64/libbpf.a 2>/dev/null || true
        rm -rf /usr/local/include/bpf 2>/dev/null || true
        rm -f /usr/local/lib/pkgconfig/libbpf.pc /usr/local/lib64/pkgconfig/libbpf.pc 2>/dev/null || true
        
        # Install with explicit paths to ensure proper installation
        make install PREFIX=/usr/local
        ldconfig
        
        # Verify what was actually installed
        echo "Checking installation results:"
        ls -la /usr/local/lib/ || echo "No /usr/local/lib directory"
        ls -la /usr/local/include/ | grep bpf || echo "No bpf headers found"
        find /usr/local -name "libbpf*" 2>/dev/null || echo "No libbpf files found in /usr/local"
        
        # Verify libbpf 1.6.2 is installed and working
        echo "Verifying libbpf 1.6.2 installation:"
        
        # Check both lib and lib64 directories (64-bit systems use lib64)
        LIBBPF_FOUND=false
        
        # Check /usr/local/lib64 first (64-bit systems)
        if [ -f /usr/local/lib64/libbpf.so.1 ]; then
          echo "libbpf.so.1 found in /usr/local/lib64"
          ls -la /usr/local/lib64/libbpf.so*
          LIBBPF_FOUND=true
        elif [ -f /usr/local/lib64/libbpf.so.1.6.2 ]; then
          echo "libbpf.so.1.6.2 found in /usr/local/lib64"
          ls -la /usr/local/lib64/libbpf.so*
          # Create symlink if needed
          if [ ! -f /usr/local/lib64/libbpf.so.1 ]; then
            ln -sf /usr/local/lib64/libbpf.so.1.6.2 /usr/local/lib64/libbpf.so.1
            echo "Created symlink libbpf.so.1 -> libbpf.so.1.6.2 in /usr/local/lib64"
          fi
          LIBBPF_FOUND=true
        fi
        
        # Check /usr/local/lib (32-bit systems or fallback)
        if [ "$LIBBPF_FOUND" = "false" ]; then
          if [ -f /usr/local/lib/libbpf.so.1 ]; then
            echo "libbpf.so.1 found in /usr/local/lib"
            ls -la /usr/local/lib/libbpf.so*
            LIBBPF_FOUND=true
          elif [ -f /usr/local/lib/libbpf.so.1.6.2 ]; then
            echo "libbpf.so.1.6.2 found in /usr/local/lib"
            ls -la /usr/local/lib/libbpf.so*
            # Create symlink if needed
            if [ ! -f /usr/local/lib/libbpf.so.1 ]; then
              ln -sf /usr/local/lib/libbpf.so.1.6.2 /usr/local/lib/libbpf.so.1
              echo "Created symlink libbpf.so.1 -> libbpf.so.1.6.2 in /usr/local/lib"
            fi
            LIBBPF_FOUND=true
          fi
        fi
        
        if [ "$LIBBPF_FOUND" = "false" ]; then
          echo "ERROR: libbpf.so.1 or libbpf.so.1.6.2 not found in /usr/local/lib or /usr/local/lib64"
          echo "Available files in /usr/local/lib:"
          ls -la /usr/local/lib/ || true
          echo "Available files in /usr/local/lib64:"
          ls -la /usr/local/lib64/ || true
          exit 1
        fi
        
        # Test libbpf version programmatically
        echo "Testing libbpf version compatibility..."
        cat > /tmp/test_libbpf.c << 'EOF'
        #include <stdio.h>
        #include <bpf/libbpf.h>
        int main() {
            unsigned int major = libbpf_major_version();
            unsigned int minor = libbpf_minor_version();
            const char *version_str = libbpf_version_string();
            
            printf("libbpf version: %u.%u (%s)\n", major, minor, version_str);
            
            // Verify we have libbpf 1.6.2
            if (major != 1 || minor < 6) {
                printf("ERROR: Expected libbpf 1.6.2, got %u.%u\n", major, minor);
                return 1;
            }
            
            printf("libbpf version check: PASSED (1.6.2)\n");
            return 0;
        }
        EOF
        
        gcc -o /tmp/test_libbpf /tmp/test_libbpf.c -L/usr/local/lib64 -lbpf -Wl,-rpath,/usr/local/lib64
        /tmp/test_libbpf
        rm -f /tmp/test_libbpf /tmp/test_libbpf.c
        
        echo "✅ libbpf 1.6.2 installed successfully"
        echo "✅ HWE kernel headers installed for kernel 6.8.x compatibility"
        echo "✅ Packages will now work on both kernel 5.15.x and 6.8.x"

    - name: Ensure bpftool
      run: |
        set -e
        echo "Checking for bpftool..."
        
        # First, try to find any existing bpftool in linux-tools directories
        BPFDIR=$(ls -d /usr/lib/linux-tools-* 2>/dev/null | head -n1 || true)
        if [ -n "$BPFDIR" ] && [ -x "$BPFDIR/bpftool" ]; then
          echo "Found existing bpftool in $BPFDIR"
          ln -sf "$BPFDIR/bpftool" /usr/local/bin/bpftool
          echo "bpftool version: $(bpftool version)"
          # Test if gen skeleton works
          echo "Testing gen skeleton functionality..."
          if bpftool gen skeleton --help >/dev/null 2>&1; then
            echo "✅ bpftool gen skeleton works correctly"
            exit 0
          else
            echo "⚠️  bpftool found but gen skeleton not working, will build from source"
          fi
        fi
        
        # Try to install linux-tools-generic-hwe-22.04 specifically
        echo "Installing linux-tools-generic-hwe-22.04 for bpftool..."
        apt-get update >/dev/null 2>&1
        if apt-get install -y linux-tools-generic-hwe-22.04 >/dev/null 2>&1; then
          echo "Successfully installed linux-tools-generic-hwe-22.04"
          # Check if it provided bpftool
          BPFDIR=$(ls -d /usr/lib/linux-tools-* 2>/dev/null | head -n1 || true)
          if [ -n "$BPFDIR" ] && [ -x "$BPFDIR/bpftool" ]; then
            ln -sf "$BPFDIR/bpftool" /usr/local/bin/bpftool
            echo "bpftool version: $(bpftool version)"
            # Test if gen skeleton works
            if bpftool gen skeleton --help >/dev/null 2>&1; then
              echo "✅ bpftool gen skeleton works correctly"
              exit 0
            else
              echo "⚠️  HWE bpftool gen skeleton not working, will build from source"
            fi
          fi
        fi
        
        # If all else fails, build from source (this ensures we have the latest features)
        echo "Building bpftool from source to ensure gen skeleton functionality..."
        
        # Install additional dependencies needed for bpftool build
        echo "Installing additional build dependencies..."
        apt-get install -y llvm-dev llvm
        
        rm -rf /tmp/bpftool-src
        git clone --depth 1 --recurse-submodules https://github.com/libbpf/bpftool.git /tmp/bpftool-src
        cd /tmp/bpftool-src
        echo "Checking bpftool source structure..."
        ls -la
        echo "Looking for Makefile..."
        find . -name "Makefile" -o -name "makefile" -o -name "*.mk" | head -10
        echo "Checking if we need to bootstrap..."
        
        # Try building with minimal features to avoid llvm-strip dependency
        if [ -f "src/Makefile" ]; then
          echo "Makefile found in src/, building from src directory with minimal features..."
          cd src
          
          # Try to build with explicit target to ensure binary is created
          echo "Building bpftool binary with explicit target..."
          make -j$(nproc) bpftool
          
          # If that didn't work, try with disabled features
          if [ ! -f "bpftool" ]; then
            echo "Trying build with disabled features..."
            make -j$(nproc) V=1 DISABLE_LLVM=1 bpftool
          fi
          
          # If still no binary, try with minimal features
          if [ ! -f "bpftool" ]; then
            echo "Trying minimal build..."
            make -j$(nproc) V=1 FEATURES_DUMP=1 bpftool
          fi
          
          # If still no binary, try clean build
          if [ ! -f "bpftool" ]; then
            echo "Trying clean build..."
            make clean
            make -j$(nproc) bpftool
          fi
          
          # Look for the binary in multiple possible locations with better search
          echo "Searching for bpftool binary after build..."
          find . -name "bpftool" -type f 2>/dev/null | head -10
          find .. -name "bpftool" -type f 2>/dev/null | head -10
          
          # Check common build output locations
          BPFTOOL_BIN=""
          if [ -f "bpftool" ]; then
            BPFTOOL_BIN="bpftool"
            echo "✅ Found bpftool in current directory"
          elif [ -f "../bpftool" ]; then
            BPFTOOL_BIN="../bpftool"
            echo "✅ Found bpftool in parent directory"
          elif [ -f "src/bpftool" ]; then
            BPFTOOL_BIN="src/bpftool"
            echo "✅ Found bpftool in src/bpftool"
          else
            # Do a more thorough search
            echo "Doing thorough search for bpftool binary..."
            ALL_BPFTOOLS=$(find . -name "bpftool" -type f 2>/dev/null)
            if [ -n "$ALL_BPFTOOLS" ]; then
              BPFTOOL_BIN=$(echo "$ALL_BPFTOOLS" | head -1)
              echo "✅ Found bpftool at: $BPFTOOL_BIN"
            else
              echo "ERROR: bpftool binary not found after building from src/"
              echo "Build directory contents:"
              ls -la
              echo "Parent directory contents:"
              ls -la ..
              exit 1
            fi
          fi
          
          if [ -n "$BPFTOOL_BIN" ]; then
            echo "✅ bpftool found at: $BPFTOOL_BIN"
            install -m 0755 "$BPFTOOL_BIN" /usr/local/bin/bpftool
          fi
          cd ..
        elif [ -f "Makefile" ]; then
          echo "Makefile found in root, building..."
          make -j$(nproc)
          if [ -f "src/bpftool" ]; then
            install -m 0755 src/bpftool /usr/local/bin/bpftool
          elif [ -f "bpftool" ]; then
            install -m 0755 bpftool /usr/local/bin/bpftool
          else
            echo "ERROR: bpftool binary not found after build"
            find . -name "bpftool" -type f
            exit 1
          fi
        elif [ -f "bootstrap.sh" ]; then
          echo "Bootstrap script found, running..."
          chmod +x bootstrap.sh
          ./bootstrap.sh
          make -j$(nproc)
          if [ -f "src/bpftool" ]; then
            install -m 0755 src/bpftool /usr/local/bin/bpftool
          elif [ -f "bpftool" ]; then
            install -m 0755 bpftool /usr/local/bin/bpftool
          else
            echo "ERROR: bpftool binary not found after bootstrap build"
            find . -name "bpftool" -type f
            exit 1
          fi
        else
          echo "ERROR: No Makefile or bootstrap script found"
          echo "Available files:"
          ls -la
          echo "Looking for Makefiles in subdirectories:"
          find . -name "Makefile" -type f
          exit 1
        fi
        cd -
        rm -rf /tmp/bpftool-src
        
        echo "Verifying bpftool installation..."
        bpftool version
        echo "Testing gen skeleton functionality..."
        if bpftool gen skeleton --help >/dev/null 2>&1; then
          echo "✅ bpftool gen skeleton works correctly"
        else
          echo "❌ ERROR: bpftool gen skeleton still not working after building from source"
          exit 1
        fi

    - name: Build application
      run: |
        echo "=== Debug: Checking kernel headers and bpftool ==="
        echo "Current bpftool: $(which bpftool)"
        echo "bpftool version: $(bpftool version)"
        echo "Testing gen skeleton:"
        bpftool gen skeleton --help | head -5
        echo "Available kernel headers:"
        ls -la /usr/src/ | grep linux-headers || echo "No linux-headers found"
        echo "HWE kernel headers:"
        ls -la /usr/src/ | grep hwe || echo "No HWE headers found"
        echo "=== Starting build ==="
        make clean
        make

    - name: Check if this is a tag release
      id: check_tag
      run: |
        echo "DEBUG: GITHUB_REF = $GITHUB_REF"
        echo "DEBUG: GITHUB_EVENT_NAME = $GITHUB_EVENT_NAME"
        echo "DEBUG: GITHUB_REF_TYPE = $GITHUB_REF_TYPE"
        if [[ "$GITHUB_REF_TYPE" == "tag" ]]; then
          echo "is_tag=true" >> $GITHUB_OUTPUT
          echo "This is a tag release, will build packages"
        else
          echo "is_tag=false" >> $GITHUB_OUTPUT
          echo "This is a push to main, build test only"
        fi
        echo "DEBUG: is_tag value set to: $(cat $GITHUB_OUTPUT || echo 'empty')"

    - name: Update changelog with version
      run: |
        VERSION=${GITHUB_REF#refs/tags/}
        VERSION=${VERSION#v}
        sed -i "s/1.0.0-1/$VERSION-1/" debian/changelog
        sed -Ei "0,/tty-egpf-monitor \([^)]+\)/s//tty-egpf-monitor (${VERSION}-1)/" debian/changelog

    - name: Use jammy control file
      run: |
        cp debian/control.jammy debian/control

    - name: Clean Debian outputs
      run: |
        rm -f ../*.deb ../*.buildinfo ../*.changes || true
        rm -rf debian/tty-egpf-monitor debian/tty-egpf-monitord debian/tty-egpf-monitor-cli || true

    - name: Build Debian package
      run: |
        echo "Building package for Ubuntu 22.04 (jammy)"
        echo "Final debian/control:"
        cat debian/control
        
        dpkg-buildpackage -b -us -uc
        ls -la ../*.deb

    - name: Copy and rename Debian packages
      run: |
        mkdir -p jammy-packages
        for f in ../*.deb; do
          base=$(basename "$f" .deb)
          cp "$f" "jammy-packages/${base}~jammy.deb"
        done

    - name: Upload jammy packages
      uses: actions/upload-artifact@v4
      with:
        name: jammy-packages-${{ github.ref_name }}
        path: jammy-packages/*.deb
        
    - name: List all built packages (always)
      if: always()
      run: |
        echo "=== Listing all .deb files found ==="
        find . -name "*.deb" -type f 2>/dev/null || echo "No .deb files found"

    - name: Debug - Check if packages were built
      if: always()
      run: |
        echo "DEBUG: Checking if packages were built..."
        echo "DEBUG: Current directory: $(pwd)"
        echo "DEBUG: is_tag output = ${{ steps.check_tag.outputs.is_tag }}"
        echo "DEBUG: GITHUB_REF = ${{ github.ref }}"
        echo "DEBUG: GITHUB_REF_NAME = ${{ github.ref_name }}"
        echo "DEBUG: Jammy packages directory:"
        ls -la jammy-packages/ 2>/dev/null || echo "No jammy-packages directory"
        echo "DEBUG: Parent directory .deb files:"
        ls -la ../*.deb 2>/dev/null || echo "No .deb files in parent directory"

  # Publish apt repository - modified to handle both packages
  publish-apt-repo:
    needs: [build-noble, build-jammy]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    permissions:
      contents: write
      pages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download noble packages artifact
      uses: actions/download-artifact@v4
      continue-on-error: true
      with:
        name: noble-packages-${{ github.ref_name }}
        path: packages/noble

    - name: Download jammy packages artifact
      uses: actions/download-artifact@v4
      continue-on-error: true
      with:
        name: jammy-packages-${{ github.ref_name }}
        path: packages/jammy
        
    - name: List all artifacts (debug)
      run: |
        echo "=== Checking what artifacts we have ==="
        echo "Current directory: $(pwd)"
        echo "Package directory structure:"
        find packages -type f 2>/dev/null || echo "No packages directory"

    - name: Install apt-utils
      run: |
        sudo apt-get update
        sudo apt-get install -y apt-utils

    - name: Debug - Check downloaded packages
      run: |
        echo "DEBUG: Checking downloaded packages..."
        echo "DEBUG: Packages directory contents:"
        ls -la packages/ 2>/dev/null || echo "No packages directory"
        echo "DEBUG: Noble artifact contents:"
        ls -la packages/noble/ 2>/dev/null || echo "No packages/noble directory"
        echo "DEBUG: Jammy artifact contents:"
        ls -la packages/jammy/ 2>/dev/null || echo "No packages/jammy directory"
        echo "DEBUG: All subdirectories:"
        find packages/ -type d 2>/dev/null || echo "No subdirectories found"
        echo "DEBUG: All .deb files:"
        find packages/ -name "*.deb" 2>/dev/null || echo "No .deb files found"
        echo "DEBUG: Pattern search for ${{ github.ref_name }}:"
        find packages/ -name "*${{ github.ref_name }}*" 2>/dev/null || echo "No artifacts matching ref_name found"

    - name: Publish apt repo to gh-pages
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        REPO: ${{ github.repository }}
      run: |
        set -ex
        echo "DEBUG: Starting APT repository publishing..."
        echo "DEBUG: GITHUB_REF = $GITHUB_REF"
        echo "DEBUG: REPO = $REPO"
        git config --global user.name "github-actions"
        git config --global user.email "github-actions@users.noreply.github.com"
        rm -rf /tmp/apt-repo
        git clone --depth 1 --branch gh-pages "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git" /tmp/apt-repo || {
          mkdir -p /tmp/apt-repo
          cd /tmp/apt-repo
          git init
          git checkout -b gh-pages
          git remote add origin "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git"
          cd -
        }

        # Create separate pool directories for each distribution
        mkdir -p /tmp/apt-repo/pool/noble
        mkdir -p /tmp/apt-repo/pool/jammy
        # Keep previous packages to maintain version history
        # Only clean if we're replacing the same version
        echo "Preserving existing packages for version history"
        
        # Copy packages to their respective pools (fail if none found)
        # This preserves version history - older versions remain available via APT
        N_FOUND=0
        while IFS= read -r f; do cp "$f" /tmp/apt-repo/pool/noble/; N_FOUND=$((N_FOUND+1)); done < <(find packages/noble -type f -name "*~noble.deb" 2>/dev/null)
        while IFS= read -r f; do cp "$f" /tmp/apt-repo/pool/jammy/; N_FOUND=$((N_FOUND+1)); done < <(find packages/jammy -type f -name "*~jammy.deb" 2>/dev/null)
        if [ "$N_FOUND" -eq 0 ]; then
          echo "ERROR: No .deb packages were found in downloaded artifacts for $GITHUB_REF" >&2
          exit 1
        fi
        
        echo "Packages in noble pool:"
        ls -la /tmp/apt-repo/pool/noble/ 2>/dev/null || echo "No noble packages"
        echo "Packages in jammy pool:"
        ls -la /tmp/apt-repo/pool/jammy/ 2>/dev/null || echo "No jammy packages"

        # Update packages for both codenames
        for CODENAME in noble jammy; do
          echo "Processing $CODENAME..."
          mkdir -p /tmp/apt-repo/dists/${CODENAME}/main/binary-amd64
          cd /tmp/apt-repo
          
          # Use codename-specific pool
          apt-ftparchive packages pool/${CODENAME} > dists/${CODENAME}/main/binary-amd64/Packages
          
          gzip -c dists/${CODENAME}/main/binary-amd64/Packages > dists/${CODENAME}/main/binary-amd64/Packages.gz
          apt-ftparchive \
            -o APT::FTPArchive::Release::Label="tty-egpf-monitor" \
            -o APT::FTPArchive::Release::Suite="${CODENAME}" \
            -o APT::FTPArchive::Release::Codename="${CODENAME}" \
            -o APT::FTPArchive::Release::Architectures="amd64" \
            -o APT::FTPArchive::Release::Components="main" \
            release dists/${CODENAME} > dists/${CODENAME}/Release
          cd -
        done

        cd /tmp/apt-repo
        touch .nojekyll
        # Copy index.html for better repository presentation
        cp "$GITHUB_WORKSPACE/index.html" ./index.html || true
        
        # Publish public key at root for clients
        KEYASC=""
        if [ -f "$GITHUB_WORKSPACE/public-apt-key.asc" ]; then
          cp "$GITHUB_WORKSPACE/public-apt-key.asc" ./public-apt-key.asc
          KEYASC="public-apt-key.asc"
        else
          CAND=$(ls "$GITHUB_WORKSPACE"/*.asc 2>/dev/null | head -n1 || true)
          if [ -n "$CAND" ]; then
            cp "$CAND" ./public-apt-key.asc
            KEYASC="public-apt-key.asc"
          elif [ -n "$GPG_PRIVATE_KEY" ]; then
            echo "$GPG_PRIVATE_KEY" | gpg --batch --yes --import
            gpg --armor --export > ./public-apt-key.asc || true
            KEYASC="public-apt-key.asc"
          fi
        fi
        if [ -n "$KEYASC" ]; then
          gpg --dearmor < "$KEYASC" > ./public-apt-key.gpg || true
        fi

        # Sign release files for both codenames
        if [ -n "$GPG_PRIVATE_KEY" ]; then
          echo "$GPG_PRIVATE_KEY" | gpg --batch --yes --import
          for CODENAME in noble jammy; do
            gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" -abs -o dists/${CODENAME}/Release.gpg dists/${CODENAME}/Release
            gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --clearsign -o dists/${CODENAME}/InRelease dists/${CODENAME}/Release || true
          done
        fi

        echo "DEBUG: Adding files to git..."
        git add -A
        echo "DEBUG: Committing changes..."
        git commit -m "Update apt repo for ${GITHUB_REF}" || git commit -m "Initialize apt repo"
        echo "DEBUG: Pushing to gh-pages branch..."
        git push -u origin gh-pages
        echo "DEBUG: APT repository publishing completed!"

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        files: 'packages/**/*.deb'
        generate_release_notes: true
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
