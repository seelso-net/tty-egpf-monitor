name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-packages:
    runs-on: ubuntu-24.04
    strategy:
      fail-fast: false
      matrix:
        codename: [ noble, jammy ]
        include:
          - codename: noble
            container: ubuntu:24.04
          - codename: jammy
            container: ubuntu:22.04
    container: ${{ matrix.container }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Cache apt packages
      uses: actions/cache@v3
      with:
        path: /var/cache/apt/archives
        key: ${{ runner.os }}-apt-${{ hashFiles('**/Makefile') }}
        restore-keys: |
          ${{ runner.os }}-apt-

    - name: Install build dependencies
      run: |
        apt-get update
        apt-get install -y \
          git \
          clang \
          make \
          flex \
          bison \
          libreadline-dev \
          libcap-dev \
          libelf-dev \
          zlib1g-dev \
          pkg-config \
          build-essential \
          linux-headers-generic \
          libbpf-dev \
          linux-tools-common \
          linux-tools-generic \
          gnupg \
          apt-utils \
          dpkg-dev \
          debhelper \
          devscripts \
          dh-make

    - name: Install correct libbpf version
      run: |
        # Install the correct libbpf version based on Ubuntu version
        if grep -q "jammy" /etc/os-release; then
          echo "Ubuntu 22.04 (jammy) detected, installing libbpf0 and libbpf-dev"
          apt-get install -y libbpf0 libbpf-dev
        elif grep -q "noble" /etc/os-release; then
          echo "Ubuntu 24.04 (noble) detected, installing libbpf1 and libbpf-dev"
          apt-get install -y libbpf1 libbpf-dev
        else
          echo "Unknown Ubuntu version, trying both"
          apt-get install -y libbpf0 libbpf1 libbpf-dev || true
        fi
        
        # Verify pkg-config finds the correct libbpf
        echo "Checking pkg-config libbpf configuration:"
        pkg-config --libs --cflags libbpf

    - name: Ensure bpftool
      run: |
        set -e
        echo "Checking for bpftool..."
        if command -v bpftool >/dev/null 2>&1; then
          echo "bpftool already available: $(bpftool version)"
          exit 0
        fi

        echo "bpftool not found, installing..."
        
        # In containers, uname -r reports host kernel which may not have packages
        # So we'll try multiple strategies without relying on exact kernel match
        
        # First, try to find any existing bpftool in linux-tools directories
        BPFDIR=$(ls -d /usr/lib/linux-tools-* 2>/dev/null | head -n1 || true)
        if [ -n "$BPFDIR" ] && [ -x "$BPFDIR/bpftool" ]; then
          echo "Found existing bpftool in $BPFDIR"
          ln -sf "$BPFDIR/bpftool" /usr/local/bin/bpftool
          bpftool version
          exit 0
        fi
        
        # Try to install any available linux-tools packages
        echo "Trying to install available linux-tools packages..."
        apt-get update >/dev/null 2>&1
        
        # Find available linux-tools packages and install them
        AVAILABLE_TOOLS=$(apt-cache search "^linux-tools-[0-9]" | grep -o "linux-tools-[0-9][^ ]*" | head -5)
        for pkg in $AVAILABLE_TOOLS; do
          echo "Trying to install $pkg..."
          if apt-get install -y "$pkg" >/dev/null 2>&1; then
            echo "Successfully installed $pkg"
            # Check if it provided bpftool
            BPFDIR=$(ls -d /usr/lib/linux-tools-* 2>/dev/null | head -n1 || true)
            if [ -n "$BPFDIR" ] && [ -x "$BPFDIR/bpftool" ]; then
              ln -sf "$BPFDIR/bpftool" /usr/local/bin/bpftool
              bpftool version
              exit 0
            fi
          fi
        done
        
        # If all else fails, build from source
        echo "No distro bpftool found, building from source..."
        rm -rf /tmp/bpftool-src
        git clone --depth 1 --recurse-submodules https://github.com/libbpf/bpftool.git /tmp/bpftool-src
        make -C /tmp/bpftool-src -j$(nproc)
        install -m 0755 /tmp/bpftool-src/src/bpftool /usr/local/bin/bpftool
        rm -rf /tmp/bpftool-src
        
        echo "Verifying bpftool installation..."
        bpftool version

    - name: Build application
      run: |
        make clean
        make

    - name: Update changelog with version
      run: |
        VERSION=${GITHUB_REF#refs/tags/}
        VERSION=${VERSION#v}
        sed -i "s/1.0.0-1/$VERSION-1/" debian/changelog
        sed -i "s/$(date -R)/$(date -R)/" debian/changelog

    - name: Clean Debian outputs
      run: |
        rm -f ../*.deb ../*.buildinfo ../*.changes || true
        rm -rf debian/tty-egpf-monitor debian/tty-egpf-monitord debian/tty-egpf-monitor-cli || true

    - name: Build Debian package
      run: |
        # Use the correct control file based on distribution
        if grep -q "jammy" /etc/os-release; then
          echo "Using jammy control file (libbpf0)"
          cp debian/control.jammy debian/control
        elif grep -q "noble" /etc/os-release; then
          echo "Using noble control file (libbpf1)"
          cp debian/control.noble debian/control
        fi
        
        echo "Final debian/control:"
        cat debian/control
        
        dpkg-buildpackage -b -us -uc
        ls -la ../*.deb

    - name: Copy Debian packages to workspace
      run: |
        cp ../*.deb .

    - name: Upload Debian package artifact
      uses: actions/upload-artifact@v4
      with:
        name: debs-${{ matrix.codename }}
        path: '*.deb'
        retention-days: 30

  publish-release:
    needs: build-packages
    runs-on: ubuntu-24.04
    permissions:
      contents: write
      pages: write
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y apt-utils gnupg

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/

    - name: Organize packages
      run: |
        mkdir -p packages/
        find artifacts/ -name "*.deb" -exec cp {} packages/ \;
        ls -la packages/
        
        # Organize packages by distribution
        mkdir -p packages-noble packages-jammy
        for deb in packages/*.deb; do
          if [ -f "$deb" ]; then
            # Check which distribution this package was built for
            if dpkg-deb -I "$deb" control | grep -q "libbpf0"; then
              echo "Package $deb is for jammy (libbpf0)"
              cp "$deb" packages-jammy/
            else
              echo "Package $deb is for noble (libbpf1)"
              cp "$deb" packages-noble/
            fi
          fi
        done

    - name: Publish apt repo to gh-pages
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        REPO: ${{ github.repository }}
      run: |
        set -e
        git config --global user.name "github-actions"
        git config --global user.email "github-actions@users.noreply.github.com"
        rm -rf /tmp/apt-repo
        git clone --depth 1 --branch gh-pages "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git" /tmp/apt-repo || {
          mkdir -p /tmp/apt-repo
          cd /tmp/apt-repo
          git init
          git checkout -b gh-pages
          git remote add origin "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git"
          cd -
        }

        # Create separate pool directories for each distribution
        mkdir -p /tmp/apt-repo/pool-noble/main /tmp/apt-repo/pool-jammy/main
        cp packages-noble/*.deb /tmp/apt-repo/pool-noble/main/ 2>/dev/null || true
        cp packages-jammy/*.deb /tmp/apt-repo/pool-jammy/main/ 2>/dev/null || true
        
        echo "Packages in noble pool:"
        ls -la /tmp/apt-repo/pool-noble/main/ 2>/dev/null || echo "No noble packages"
        echo "Packages in jammy pool:"
        ls -la /tmp/apt-repo/pool-jammy/main/ 2>/dev/null || echo "No jammy packages"

        # Update packages for both codenames
        for CODENAME in noble jammy; do
          echo "Processing $CODENAME..."
          mkdir -p /tmp/apt-repo/dists/${CODENAME}/main/binary-amd64
          cd /tmp/apt-repo
          
          # Use distribution-specific pool for each codename
          if [ "$CODENAME" = "noble" ]; then
            apt-ftparchive packages pool-noble/main > dists/${CODENAME}/main/binary-amd64/Packages
          else
            apt-ftparchive packages pool-jammy/main > dists/${CODENAME}/main/binary-amd64/Packages
          fi
          gzip -c dists/${CODENAME}/main/binary-amd64/Packages > dists/${CODENAME}/main/binary-amd64/Packages.gz
          apt-ftparchive \
            -o APT::FTPArchive::Release::Label="tty-egpf-monitor" \
            -o APT::FTPArchive::Release::Suite="${CODENAME}" \
            -o APT::FTPArchive::Release::Codename="${CODENAME}" \
            -o APT::FTPArchive::Release::Architectures="amd64" \
            -o APT::FTPArchive::Release::Components="main" \
            release dists/${CODENAME} > dists/${CODENAME}/Release
          cd -
        done

        cd /tmp/apt-repo
        touch .nojekyll
        # Copy index.html for better repository presentation
        cp "$GITHUB_WORKSPACE/index.html" ./index.html || true
        
        # Publish public key at root for clients (both .asc and .gpg)
        KEYASC=""
        if [ -f "$GITHUB_WORKSPACE/public-apt-key.asc" ]; then
          cp "$GITHUB_WORKSPACE/public-apt-key.asc" ./public-apt-key.asc
          KEYASC="public-apt-key.asc"
        else
          CAND=$(ls "$GITHUB_WORKSPACE"/*.asc 2>/dev/null | head -n1 || true)
          if [ -n "$CAND" ]; then
            cp "$CAND" ./public-apt-key.asc
            KEYASC="public-apt-key.asc"
          elif [ -n "$GPG_PRIVATE_KEY" ]; then
            echo "$GPG_PRIVATE_KEY" | gpg --batch --yes --import
            gpg --armor --export > ./public-apt-key.asc || true
            KEYASC="public-apt-key.asc"
          fi
        fi
        if [ -n "$KEYASC" ]; then
          gpg --dearmor < "$KEYASC" > ./public-apt-key.gpg || true
        fi

        # Sign release files for both codenames
        if [ -n "$GPG_PRIVATE_KEY" ]; then
          echo "$GPG_PRIVATE_KEY" | gpg --batch --yes --import
          for CODENAME in noble jammy; do
            gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" -abs -o dists/${CODENAME}/Release.gpg dists/${CODENAME}/Release
            gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --clearsign -o dists/${CODENAME}/InRelease dists/${CODENAME}/Release || true
          done
        fi

        git add -A
        git commit -m "Update apt repo for ${GITHUB_REF}" || git commit -m "Initialize apt repo"
        git push -u origin gh-pages

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        files: 'packages/*.deb'
        generate_release_notes: true
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
