name: Release

on:
  push:
    branches:
      - main
    tags:
      - 'v*'

jobs:
  # Build for Ubuntu 24.04 (noble) - existing job
  build-noble:
    runs-on: ubuntu-24.04
    container: ubuntu:24.04
    permissions:
      contents: write
      pages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install build dependencies
      run: |
        apt-get update
        apt-get install -y \
          git \
          clang \
          make \
          flex \
          bison \
          libreadline-dev \
          libcap-dev \
          libelf-dev \
          zlib1g-dev \
          pkg-config \
          build-essential \
          linux-headers-generic \
          libbpf-dev \
          libsystemd-dev \
          linux-tools-common \
          linux-tools-generic \
          gnupg \
          apt-utils \
          dpkg-dev \
          debhelper \
          devscripts \
          dh-make

    - name: Install correct libbpf version
      run: |
        # For noble, ensure we have libbpf1 and remove any libbpf0
        echo "Ubuntu 24.04 (noble) detected, installing libbpf1 and libbpf-dev"
        apt-get install -y libbpf1 libbpf-dev
        
        # Remove libbpf0 if it exists to ensure we link against libbpf1
        apt-get remove -y libbpf0 || true
        apt-get autoremove -y
        
        # Verify pkg-config finds the correct libbpf
        echo "Checking pkg-config libbpf configuration:"
        pkg-config --libs --cflags libbpf

    - name: Ensure bpftool
      run: |
        set -e
        echo "Checking for bpftool..."
        if command -v bpftool >/dev/null 2>&1; then
          echo "bpftool already available: $(bpftool version)"
          exit 0
        fi

        echo "bpftool not found, installing..."
        
        # First, try to find any existing bpftool in linux-tools directories
        BPFDIR=$(ls -d /usr/lib/linux-tools-* 2>/dev/null | head -n1 || true)
        if [ -n "$BPFDIR" ] && [ -x "$BPFDIR/bpftool" ]; then
          echo "Found existing bpftool in $BPFDIR"
          ln -sf "$BPFDIR/bpftool" /usr/local/bin/bpftool
          bpftool version
          exit 0
        fi
        
        # Try to install any available linux-tools packages
        echo "Trying to install available linux-tools packages..."
        apt-get update >/dev/null 2>&1
        
        # Find available linux-tools packages and install them
        AVAILABLE_TOOLS=$(apt-cache search "^linux-tools-[0-9]" | grep -o "linux-tools-[0-9][^ ]*" | head -5)
        for pkg in $AVAILABLE_TOOLS; do
          echo "Trying to install $pkg..."
          if apt-get install -y "$pkg" >/dev/null 2>&1; then
            echo "Successfully installed $pkg"
            # Check if it provided bpftool
            BPFDIR=$(ls -d /usr/lib/linux-tools-* 2>/dev/null | head -n1 || true)
            if [ -n "$BPFDIR" ] && [ -x "$BPFDIR/bpftool" ]; then
              ln -sf "$BPFDIR/bpftool" /usr/local/bin/bpftool
              bpftool version
              exit 0
            fi
          fi
        done
        
        # If all else fails, build from source
        echo "No distro bpftool found, building from source..."
        rm -rf /tmp/bpftool-src
        git clone --depth 1 --recurse-submodules https://github.com/libbpf/bpftool.git /tmp/bpftool-src
        make -C /tmp/bpftool-src -j$(nproc)
        install -m 0755 /tmp/bpftool-src/src/bpftool /usr/local/bin/bpftool
        rm -rf /tmp/bpftool-src
        
        echo "Verifying bpftool installation..."
        bpftool version

    - name: Build application
      run: |
        make clean
        make

    - name: Check if this is a tag release
      id: check_tag
      run: |
        echo "DEBUG: GITHUB_REF = $GITHUB_REF"
        echo "DEBUG: GITHUB_EVENT_NAME = $GITHUB_EVENT_NAME"
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          echo "is_tag=true" >> $GITHUB_OUTPUT
          echo "This is a tag release, will build packages"
        else
          echo "is_tag=false" >> $GITHUB_OUTPUT
          echo "This is a push to main, build test only"
        fi

    - name: Update changelog with version (tag only)
      if: steps.check_tag.outputs.is_tag == 'true'
      run: |
        VERSION=${GITHUB_REF#refs/tags/}
        VERSION=${VERSION#v}
        sed -i "s/1.0.0-1/$VERSION-1/" debian/changelog
        sed -i "s/$(date -R)/$(date -R)/" debian/changelog

    - name: Clean Debian outputs (tag only)
      if: steps.check_tag.outputs.is_tag == 'true'
      run: |
        rm -f ../*.deb ../*.buildinfo ../*.changes || true
        rm -rf debian/tty-egpf-monitor debian/tty-egpf-monitord debian/tty-egpf-monitor-cli || true

    - name: Build Debian package (tag only)
      if: steps.check_tag.outputs.is_tag == 'true'
      run: |
        echo "Building package for Ubuntu 24.04 (noble)"
        echo "Final debian/control:"
        cat debian/control
        
        dpkg-buildpackage -b -us -uc
        ls -la ../*.deb

    - name: Copy and rename Debian packages (tag only)
      if: steps.check_tag.outputs.is_tag == 'true'
      run: |
        mkdir -p noble-packages
        for f in ../*.deb; do
          base=$(basename "$f" .deb)
          cp "$f" "noble-packages/${base}~noble.deb"
        done

    - name: Upload noble packages (tag only)
      if: steps.check_tag.outputs.is_tag == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: noble-packages-${{ github.ref_name }}
        path: noble-packages/*.deb

    - name: Debug - Check if packages were built
      run: |
        echo "DEBUG: Checking if packages were built..."
        echo "DEBUG: Current directory: $(pwd)"
        echo "DEBUG: Noble packages directory:"
        ls -la noble-packages/ 2>/dev/null || echo "No noble-packages directory"
        echo "DEBUG: Parent directory .deb files:"
        ls -la ../*.deb 2>/dev/null || echo "No .deb files in parent directory"

  # Build for Ubuntu 22.04 (jammy) - new job
  build-jammy:
    runs-on: ubuntu-latest
    container: ubuntu:22.04
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install build dependencies
      run: |
        apt-get update
        apt-get install -y \
          git \
          clang \
          make \
          flex \
          bison \
          libreadline-dev \
          libcap-dev \
          libelf-dev \
          zlib1g-dev \
          pkg-config \
          build-essential \
          linux-headers-generic \
          libbpf-dev \
          libsystemd-dev \
          linux-tools-common \
          linux-tools-generic \
          gnupg \
          apt-utils \
          dpkg-dev \
          debhelper \
          devscripts \
          dh-make

    - name: Install compatible libbpf version
      run: |
        # For jammy, build and install newer libbpf to ensure compatibility
        echo "Ubuntu 22.04 (jammy) detected, building compatible libbpf version"
        
        # Install build dependencies for libbpf
        apt-get install -y libelf-dev zlib1g-dev
        
        # Build and install newer libbpf
        cd /tmp
        git clone --depth 1 https://github.com/libbpf/libbpf.git
        cd libbpf/src
        make && make install
        ldconfig
        
        # Ensure libbpf is in the expected location
        if [ ! -f /usr/local/lib/libbpf.so.1 ]; then
          echo "libbpf not in /usr/local/lib, checking other locations..."
          LIBBPF_LOCATION=$(find /usr -name "libbpf.so.1" 2>/dev/null | head -1)
          if [ -n "$LIBBPF_LOCATION" ]; then
            echo "Found libbpf at: $LIBBPF_LOCATION"
            LIBBPF_DIR=$(dirname "$LIBBPF_LOCATION")
            # Create symlink to /usr/local/lib if needed
            if [ "$LIBBPF_DIR" != "/usr/local/lib" ]; then
              mkdir -p /usr/local/lib
              ln -sf "$LIBBPF_LOCATION" /usr/local/lib/libbpf.so.1
              ln -sf "$LIBBPF_DIR/libbpf.so" /usr/local/lib/libbpf.so
              echo "Created symlinks in /usr/local/lib"
            fi
          else
            echo "ERROR: libbpf.so.1 not found anywhere"
            exit 1
          fi
        fi
        
        # Update pkg-config to use the new libbpf
        if [ -f /usr/local/lib/pkgconfig/libbpf.pc ]; then
          echo "Updating pkg-config configuration..."
          export PKG_CONFIG_PATH="/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH"
          export LD_LIBRARY_PATH="/usr/local/lib:$LD_LIBRARY_PATH"
        fi
        
        # Verify the libbpf version
        echo "libbpf version check:"
        if command -v pkg-config >/dev/null 2>&1; then
          echo "pkg-config libbpf version:"
          pkg-config --modversion libbpf || echo "pkg-config not available"
          echo "pkg-config libbpf libs:"
          pkg-config --libs libbpf || echo "pkg-config not available"
        fi
        
        # Check where libbpf was actually installed
        echo "Checking libbpf installation locations:"
        find /usr -name "libbpf.so*" 2>/dev/null || true
        find /usr/local -name "libbpf.so*" 2>/dev/null || true
        
        # Verify libbpf.so.1 is available in standard locations
        if [ -f /usr/local/lib/libbpf.so.1 ]; then
          echo "libbpf.so.1 found in /usr/local/lib"
          ls -la /usr/local/lib/libbpf.so*
        elif [ -f /usr/lib/x86_64-linux-gnu/libbpf.so.1 ]; then
          echo "libbpf.so.1 found in /usr/lib/x86_64-linux-gnu"
          ls -la /usr/lib/x86_64-linux-gnu/libbpf.so*
        else
          echo "ERROR: libbpf.so.1 not found in expected locations"
          exit 1
        fi
        
        # Test libbpf version programmatically
        echo "Testing libbpf version compatibility..."
        cat > /tmp/test_libbpf.c << 'EOF'
        #include <stdio.h>
        #include <bpf/libbpf.h>
        int main() {
            unsigned int major = libbpf_major_version();
            unsigned int minor = libbpf_minor_version();
            const char *version_str = libbpf_version_string();
            
            printf("libbpf version: %u.%u (%s)\n", major, minor, version_str);
            
            // Check if version is compatible (need at least 0.8.0 for proper skeleton support)
            if (major == 0 && minor < 8) {
                printf("ERROR: libbpf version %u.%u is not compatible\n", major, minor);
                printf("ERROR: This version has known issues with BPF skeleton attachment\n");
                return 1;
            }
            
            printf("libbpf version check: PASSED\n");
            return 0;
        }
        EOF
        
        gcc -o /tmp/test_libbpf /tmp/test_libbpf.c -L/usr/local/lib -lbpf -Wl,-rpath,/usr/local/lib
        /tmp/test_libbpf
        rm -f /tmp/test_libbpf /tmp/test_libbpf.c

    - name: Ensure bpftool
      run: |
        set -e
        echo "Checking for bpftool..."
        if command -v bpftool >/dev/null 2>&1; then
          echo "bpftool already available: $(bpftool version)"
          exit 0
        fi

        echo "bpftool not found, installing..."
        
        # First, try to find any existing bpftool in linux-tools directories
        BPFDIR=$(ls -d /usr/lib/linux-tools-* 2>/dev/null | head -n1 || true)
        if [ -n "$BPFDIR" ] && [ -x "$BPFDIR/bpftool" ]; then
          echo "Found existing bpftool in $BPFDIR"
          ln -sf "$BPFDIR/bpftool" /usr/local/bin/bpftool
          bpftool version
          exit 0
        fi
        
        # Try to install any available linux-tools packages
        echo "Trying to install available linux-tools packages..."
        apt-get update >/dev/null 2>&1
        
        # Find available linux-tools packages and install them
        AVAILABLE_TOOLS=$(apt-cache search "^linux-tools-[0-9]" | grep -o "linux-tools-[0-9][^ ]*" | head -5)
        for pkg in $AVAILABLE_TOOLS; do
          echo "Trying to install $pkg..."
          if apt-get install -y "$pkg" >/dev/null 2>&1; then
            echo "Successfully installed $pkg"
            # Check if it provided bpftool
            BPFDIR=$(ls -d /usr/lib/linux-tools-* 2>/dev/null | head -n1 || true)
            if [ -n "$BPFDIR" ] && [ -x "$BPFDIR/bpftool" ]; then
              ln -sf "$BPFDIR/bpftool" /usr/local/bin/bpftool
              bpftool version
              exit 0
            fi
          fi
        done
        
        # If all else fails, build from source
        echo "No distro bpftool found, building from source..."
        rm -rf /tmp/bpftool-src
        git clone --depth 1 --recurse-submodules https://github.com/libbpf/bpftool.git /tmp/bpftool-src
        make -C /tmp/bpftool-src -j$(nproc)
        install -m 0755 /tmp/bpftool-src/src/bpftool /usr/local/bin/bpftool
        rm -rf /tmp/bpftool-src
        
        echo "Verifying bpftool installation..."
        bpftool version

    - name: Build application
      run: |
        make clean
        make

    - name: Check if this is a tag release
      id: check_tag
      run: |
        echo "DEBUG: GITHUB_REF = $GITHUB_REF"
        echo "DEBUG: GITHUB_EVENT_NAME = $GITHUB_EVENT_NAME"
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          echo "is_tag=true" >> $GITHUB_OUTPUT
          echo "This is a tag release, will build packages"
        else
          echo "is_tag=false" >> $GITHUB_OUTPUT
          echo "This is a push to main, build test only"
        fi

    - name: Update changelog with version (tag only)
      if: steps.check_tag.outputs.is_tag == 'true'
      run: |
        VERSION=${GITHUB_REF#refs/tags/}
        VERSION=${VERSION#v}
        sed -i "s/1.0.0-1/$VERSION-1/" debian/changelog
        sed -i "s/$(date -R)/$(date -R)/" debian/changelog

    - name: Use jammy control file (tag only)
      if: steps.check_tag.outputs.is_tag == 'true'
      run: |
        cp debian/control.jammy debian/control

    - name: Clean Debian outputs (tag only)
      if: steps.check_tag.outputs.is_tag == 'true'
      run: |
        rm -f ../*.deb ../*.buildinfo ../*.changes || true
        rm -rf debian/tty-egpf-monitor debian/tty-egpf-monitord debian/tty-egpf-monitor-cli || true

    - name: Build Debian package (tag only)
      if: steps.check_tag.outputs.is_tag == 'true'
      run: |
        echo "Building package for Ubuntu 22.04 (jammy)"
        echo "Final debian/control:"
        cat debian/control
        
        dpkg-buildpackage -b -us -uc
        ls -la ../*.deb

    - name: Copy and rename Debian packages (tag only)
      if: steps.check_tag.outputs.is_tag == 'true'
      run: |
        mkdir -p jammy-packages
        for f in ../*.deb; do
          base=$(basename "$f" .deb)
          cp "$f" "jammy-packages/${base}~jammy.deb"
        done

    - name: Upload jammy packages (tag only)
      if: steps.check_tag.outputs.is_tag == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: jammy-packages-${{ github.ref_name }}
        path: jammy-packages/*.deb

    - name: Debug - Check if packages were built
      run: |
        echo "DEBUG: Checking if packages were built..."
        echo "DEBUG: Current directory: $(pwd)"
        echo "DEBUG: Jammy packages directory:"
        ls -la jammy-packages/ 2>/dev/null || echo "No jammy-packages directory"
        echo "DEBUG: Parent directory .deb files:"
        ls -la ../*.deb 2>/dev/null || echo "No .deb files in parent directory"

  # Publish apt repository - modified to handle both packages
  publish-apt-repo:
    needs: [build-noble, build-jammy]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    permissions:
      contents: write
      pages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download noble packages artifact
      uses: actions/download-artifact@v4
      with:
        name: noble-packages-${{ github.ref_name }}
        path: packages/noble

    - name: Download jammy packages artifact
      uses: actions/download-artifact@v4
      with:
        name: jammy-packages-${{ github.ref_name }}
        path: packages/jammy

    - name: Install apt-utils
      run: |
        sudo apt-get update
        sudo apt-get install -y apt-utils

    - name: Debug - Check downloaded packages
      run: |
        echo "DEBUG: Checking downloaded packages..."
        echo "DEBUG: Packages directory contents:"
        ls -la packages/ 2>/dev/null || echo "No packages directory"
        echo "DEBUG: Noble artifact contents:"
        ls -la packages/noble/ 2>/dev/null || echo "No packages/noble directory"
        echo "DEBUG: Jammy artifact contents:"
        ls -la packages/jammy/ 2>/dev/null || echo "No packages/jammy directory"
        echo "DEBUG: All subdirectories:"
        find packages/ -type d 2>/dev/null || echo "No subdirectories found"
        echo "DEBUG: All .deb files:"
        find packages/ -name "*.deb" 2>/dev/null || echo "No .deb files found"
        echo "DEBUG: Pattern search for ${{ github.ref_name }}:"
        find packages/ -name "*${{ github.ref_name }}*" 2>/dev/null || echo "No artifacts matching ref_name found"

    - name: Publish apt repo to gh-pages
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        REPO: ${{ github.repository }}
      run: |
        set -ex
        echo "DEBUG: Starting APT repository publishing..."
        echo "DEBUG: GITHUB_REF = $GITHUB_REF"
        echo "DEBUG: REPO = $REPO"
        git config --global user.name "github-actions"
        git config --global user.email "github-actions@users.noreply.github.com"
        rm -rf /tmp/apt-repo
        git clone --depth 1 --branch gh-pages "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git" /tmp/apt-repo || {
          mkdir -p /tmp/apt-repo
          cd /tmp/apt-repo
          git init
          git checkout -b gh-pages
          git remote add origin "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git"
          cd -
        }

        # Create separate pool directories for each distribution
        mkdir -p /tmp/apt-repo/pool/noble
        mkdir -p /tmp/apt-repo/pool/jammy
        # Clean previous packages to avoid stale versions
        rm -f /tmp/apt-repo/pool/noble/*.deb || true
        rm -f /tmp/apt-repo/pool/jammy/*.deb || true
        
        # Copy packages to their respective pools (fail if none found)
        N_FOUND=0
        while IFS= read -r f; do cp "$f" /tmp/apt-repo/pool/noble/; N_FOUND=$((N_FOUND+1)); done < <(find packages/noble -type f -name "*~noble.deb" 2>/dev/null)
        while IFS= read -r f; do cp "$f" /tmp/apt-repo/pool/jammy/; N_FOUND=$((N_FOUND+1)); done < <(find packages/jammy -type f -name "*~jammy.deb" 2>/dev/null)
        if [ "$N_FOUND" -eq 0 ]; then
          echo "ERROR: No .deb packages were found in downloaded artifacts for $GITHUB_REF" >&2
          exit 1
        fi
        
        echo "Packages in noble pool:"
        ls -la /tmp/apt-repo/pool/noble/ 2>/dev/null || echo "No noble packages"
        echo "Packages in jammy pool:"
        ls -la /tmp/apt-repo/pool/jammy/ 2>/dev/null || echo "No jammy packages"

        # Update packages for both codenames
        for CODENAME in noble jammy; do
          echo "Processing $CODENAME..."
          mkdir -p /tmp/apt-repo/dists/${CODENAME}/main/binary-amd64
          cd /tmp/apt-repo
          
          # Use codename-specific pool
          apt-ftparchive packages pool/${CODENAME} > dists/${CODENAME}/main/binary-amd64/Packages
          
          gzip -c dists/${CODENAME}/main/binary-amd64/Packages > dists/${CODENAME}/main/binary-amd64/Packages.gz
          apt-ftparchive \
            -o APT::FTPArchive::Release::Label="tty-egpf-monitor" \
            -o APT::FTPArchive::Release::Suite="${CODENAME}" \
            -o APT::FTPArchive::Release::Codename="${CODENAME}" \
            -o APT::FTPArchive::Release::Architectures="amd64" \
            -o APT::FTPArchive::Release::Components="main" \
            release dists/${CODENAME} > dists/${CODENAME}/Release
          cd -
        done

        cd /tmp/apt-repo
        touch .nojekyll
        # Copy index.html for better repository presentation
        cp "$GITHUB_WORKSPACE/index.html" ./index.html || true
        
        # Publish public key at root for clients
        KEYASC=""
        if [ -f "$GITHUB_WORKSPACE/public-apt-key.asc" ]; then
          cp "$GITHUB_WORKSPACE/public-apt-key.asc" ./public-apt-key.asc
          KEYASC="public-apt-key.asc"
        else
          CAND=$(ls "$GITHUB_WORKSPACE"/*.asc 2>/dev/null | head -n1 || true)
          if [ -n "$CAND" ]; then
            cp "$CAND" ./public-apt-key.asc
            KEYASC="public-apt-key.asc"
          elif [ -n "$GPG_PRIVATE_KEY" ]; then
            echo "$GPG_PRIVATE_KEY" | gpg --batch --yes --import
            gpg --armor --export > ./public-apt-key.asc || true
            KEYASC="public-apt-key.asc"
          fi
        fi
        if [ -n "$KEYASC" ]; then
          gpg --dearmor < "$KEYASC" > ./public-apt-key.gpg || true
        fi

        # Sign release files for both codenames
        if [ -n "$GPG_PRIVATE_KEY" ]; then
          echo "$GPG_PRIVATE_KEY" | gpg --batch --yes --import
          for CODENAME in noble jammy; do
            gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" -abs -o dists/${CODENAME}/Release.gpg dists/${CODENAME}/Release
            gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --clearsign -o dists/${CODENAME}/InRelease dists/${CODENAME}/Release || true
          done
        fi

        echo "DEBUG: Adding files to git..."
        git add -A
        echo "DEBUG: Committing changes..."
        git commit -m "Update apt repo for ${GITHUB_REF}" || git commit -m "Initialize apt repo"
        echo "DEBUG: Pushing to gh-pages branch..."
        git push -u origin gh-pages
        echo "DEBUG: APT repository publishing completed!"

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        files: 'packages/**/*.deb'
        generate_release_notes: true
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
